# Synchronous Communication

## Overview
Synchronous communication is a direct communication between components (in our case, microservices) where one component waits for a response from another before proceeding. Synchronous communication patterns are often used for scenarios requiring immediate responses or real-time interactions.

![alt text](pics/sync-communication.drawio.svg)

### Key Characteristics

- **Direct Interaction**: Components communicate directly with each other.

- **Immediate Feedback**: The sender receives a response right after the request is processed.

- **Blocking**: The sender waits for the receiver to process the request and send a response.

- **Tight Coupling**: Components are often tightly coupled, as the sender relies on the receiver's immediate response.

### When to Use Synchronous Communication

Synchronous communication is best suited for scenarios where immediate feedback is required, such as:
- User interactions (e.g., web applications)
- Real-time data processing
- Transactions that require immediate confirmation

### Weaknesses
- **Scalability**: Synchronous communication can lead to bottlenecks, as the sender must wait for the receiver to respond, which can slow down the system under heavy load.

- **Error Handling**: If the receiver fails or is slow, the sender may experience timeouts or errors, complicating error handling and recovery.

- **Complexity**: Managing synchronous interactions can increase complexity, especially in distributed systems where network latency and failures can affect communication.

### Technology overview

- **REST**: A conventional, widely-used HTTP-based API approach
- **GraphQL**: A flexible query language for APIs
- **gRPC**: A high-performance Remote Procedure Call (RPC) framework

Each has distinct characteristics and is suited for specific contexts, which we'll explore in detail.

## REST
### Overview
**REST (Representational State Transfer)** is an architectural style for designing networked applications. It relies on a stateless, client-server, cacheable communication protocol â€” typically HTTP.

![alt text](pics/REST.drawio.svg)

REST APIs are built around resources, which are identified by URLs. Clients interact with these resources following the CRUD operations: Create, Read, Update, and Delete. These operations are typically mapped to HTTP methods as follows:
| Method | Operation |
|--------|-----------|
| GET    | Read      |
| POST   | Create    |
| PUT    | Update    |
| DELETE | Delete    |

### How It Works
- Clients send HTTP requests to specific URLs representing resources specifying the desired operation. Usually, these requests include headers and sometimes a body with additional data.
- The server processes these requests and returns responses, typically serialized in JSON format. Responses include status codes that indicate success or failure (e.g., 200 OK, 404 Not Found).
### Strengths
- **Simplicity and ease of use**
- **Broad compatibility with HTTP clients and tools** 
- **Well-defined standards and conventions**
### Weaknesses
- **Over-fetching or under-fetching data**: Clients may receive more or less data than needed, leading to inefficiencies.
- **Limited flexibility in querying data**: Clients must know the structure of the API and cannot easily request custom data shapes.
- **No code generation**: REST does not offer any built-in code generation mechanisms, so developers must use additional third-party tools if they require this feature.

### Implementations

#### Spring Boot
- **Language**: Java
- **Strengths**:
  - Strong ecosystem and tooling (e.g., Spring ecosystem)
  - Mature support for REST APIs (e.g., Spring MVC)
  - Integration with enterprise systems 
- **Weaknesses**:
  - Verbose configuration and boilerplate
  - Higher memory usage

#### FastAPI
- **Language**: Python
- **Strengths**:
  - Lightweight and fast
  - Asynchronous support out of the box
  - Great for rapid development
- **Weaknesses**:
  - Smaller ecosystem compared to Spring
  - Best suited for simpler or data-centric applications


## GraphQL

### Overview
**GraphQL** is a query language for APIs and a runtime for executing those queries. Unlike REST, it allows clients to request exactly the data they need on a single endpoint.

![alt text](pics/GraphQL.drawio.svg) 

### How It Works
- Clients send structured queries with a POST request to a **single endpoint**.
- The server responds with precisely the data described in the query.

### Strengths
- **Avoids over-fetching and under-fetching**
- **Strong introspection and type system**: Clients can explore the API schema and understand available data types and relationships.
- **Single endpoint**: Simplifies API management and versioning.

### Weaknesses
- **More complex to cache and monitor**: Caching can be challenging due to the dynamic nature of queries.
- **Requires a schema**: Clients must understand the schema to construct queries.
- **Potential for complex queries**: Clients can construct complex queries that may lead to performance issues if not managed properly.

### Implementation

#### Strawberry
- **Language**: Python
- **Strengths**:
  - Type-safe GraphQL server
  - Easy to use with Python's type hints
  - Good integration with Python web frameworks
- **Weaknesses**:
    - Smaller ecosystem compared to REST frameworks
    - Less mature tooling for monitoring and caching

## gRPC with Protobuf

### Overview
**gRPC** is a high-performance RPC framework developed by Google. It uses HTTP/2 and Protocol Buffers for serialization.

![alt text](pics/gRPC.drawio.svg)

### What is RPC?
**RPC (Remote Procedure Call)** is a protocol that allows a program to execute a procedure (subroutine) on a remote server as if it were a local call. An RPC API uses a protocol like HTTP, TCP, or UDP as its underlying data exchange mechanism.

### How It Works
- Clients call methods on a remote service via a code stub.
- The server implements these methods and responds with the results.
- Messages are serialized with **Protobuf**, a language-agnostic binary format which is efficient for both size and speed, and then transmitted over HTTP/2, which supports features like multiplexing and flow control.

### Strengths
- **Very efficient in terms of bandwidth and latency**: by using Protobuf and HTTP/2, gRPC minimizes the size of messages and reduces latency.
- **Strongly typed contracts via Protobuf**: Clients and servers share a well-defined schema, ensuring type safety and reducing runtime errors.
- **Supports bi-directional streaming**: gRPC allows for bi-directional streaming, making it suitable for real-time applications.


### Weaknesses
- **Harder to use manually**
- **Requires additional tooling** (e.g., `protoc` compiler)
- **Limited browser support**: gRPC is not natively supported in browsers, which can complicate client-side development.

### Implementation

#### gRPC Python
- **Language**: Python
- **Strengths**:
  - **High performance and low latency**
  - **Code generation from Protobuf definitions**
- **Weaknesses**:
  - **More complex setup compared to REST**

## Comparison Table

| Feature                  | REST (Spring) | REST (FastAPI) | GraphQL | gRPC   |
|--------------------------|----------------|----------------|---------|--------|
| Protocol                | HTTP/1.1       | HTTP/1.1       | HTTP    | HTTP/2 |
| Schema First            | No              | No              | Yes       | Yes      |
| Flexible Querying       | No              | No              | Yes       | No      |
| Performance             | High         | High           | Medium  | Very High |
| Payload Format          | JSON           | JSON           | JSON    | Protobuf |
| Streaming support        | No              | No              | No       | Yes      |


## Use Cases

### REST
- Public APIs
- CRUD-heavy applications
- Systems requiring broad compatibility with HTTP tools and clients

### GraphQL
- Client-rich applications needing custom data selection
- Applications with complex data relationships
- Mobile applications where bandwidth is a concern

### gRPC
- High-performance backend communication
- Microservices architectures requiring efficient communication
- Real-time data streams or telemetry (e.g., IoT, ML pipelines)


## References
- [The difference betweeen GraphQL and REST by AWS](https://aws.amazon.com/compare/the-difference-between-graphql-and-rest/)
- [The difference betweeen gRPC and REST by AWS](https://aws.amazon.com/compare/the-difference-between-grpc-and-rest/)